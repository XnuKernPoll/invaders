package world
import (
	"math/rand"
	"time"
	"fmt"
) 

func (WM *WorldMap) UpdateCity(cityName string, f func(City)City) *WorldMap {
	city, b := WM.cities.Get(cityName)
	
	if b != true {
		return WM
	} 
	
	city1 := f(city)
	WM.cities.Put(cityName, city1) 
	return WM 
	
}



func FilterConns(conns []Connection, F func (Connection) bool ) []Connection {
	var retVal []Connection
	
	for _, x := range conns {

		if F(x) {
		retVal = append(retVal, x)

		} else {
			continue
		}
		
	}

	return retVal
}



func FilterAliens(aliens map[int]Alien, F func(Alien) bool ) []Alien {

	var retVal []Alien
	
	for _, v := range aliens {

		if F(v) {
		retVal = append(retVal, v)

		} else {
			continue
		}
		
	}

	return retVal
}   






func (C *City) AddConn(conn Connection) City {
	nconns := append(C.connections, conn)
	return City{C.name, nconns}	
}


func (C *City) RmConn(city_name string) City {
	fn := func(C Connection) bool {
		return C.city != city_name
	}

	
	nconns := FilterConns(C.connections, fn)
	return City{C.name, nconns}	
} 




func (C *City) RandomConn() *Connection  {

	
	rand.Seed(time.Now().Unix())
	
	if len(C.connections) != 0 { 
		n := rand.Intn(len(C.connections))
		return &C.connections[n]
	} else {return nil}

	
}


func (WM *WorldMap) RemoveAlien(alien Alien) {

	WM.aliens.Delete(alien.id)
	alien.ch <- RMSG{disconnect}
}



func (WM *WorldMap) DestroyCity(cityName string) *WorldMap {

	
	city, e := WM.cities.Get(cityName)

	
	if e != true {
		return WM
	} 

	
	conns := city.connections
	
	fn := func(city City) City {
		return city.RmConn(cityName) 
	}

	
	WM.cities.Delete(cityName)

	
	for _, x := range conns {
		WM.UpdateCity(x.city, fn)
	}

	
	return WM 
	
}



func (WM *WorldMap) RemoveRivals(city_name string) bool {

	defer func() {
		if r := recover(); r != nil {
			fmt.Println(r)
			return
		}
    }()
	
	
	pred := func (a Alien) bool {return a.location == city_name}

	
	rivals := FilterAliens(WM.aliens.Copy(), pred)

	
	
	b := len(rivals) >= 2

	if b != true {
		return false 
	} 
	
	var ids []int 


	for _, x := range rivals {
		id := x.id
		ids = append(ids, id)
	} 

	
	for _, x := range rivals {
		WM.RemoveAlien(x)
	}

	
	WM.DestroyCity(city_name)

	fmt.Printf("Aliens %v died in battle, and city %s was destroyed \n", ids, city_name)
	return true
}  





func (Srv *Server) Move(alienID int) {

	WM := Srv.World
	
	defer func() {
		if r := recover(); r != nil {
			fmt.Println(r)
			return
		}
	}()

	alien, e := WM.aliens.Get(alienID)
	if e != true {return} 


	
	city_name := alien.location


	current_city, e1 := WM.cities.Get(city_name)

	if e1 != true {
	//	fmt.Printf("Alien %d died in the destruction of %s\n", alien.id, city_name)
		WM.RemoveAlien(alien)
		return
	}
	


	if alien.ctr >= 1000 {
		WM.RemoveAlien(alien)
		fmt.Printf("Alien %d was removed due to making 10000 moves \n", alien.id) 
		return 
	}

	new_conn := current_city.RandomConn()
	


	if new_conn == nil {
		WM.RemoveAlien(alien)
		fmt.Printf("Alien %d, was trapped in city %s and starved to death \n", alien.id, city_name) 
		return 
	}

	new_cname := new_conn.city
	fmt.Println(alien.id,alien.ctr)
	alien.ctr++
	a1 := Alien{alien.id, alien.ctr, new_cname, alien.ch}

	
	WM.aliens.Put(a1.id, a1)

	b := WM.RemoveRivals(new_cname)
	
	if b != true {
		a1.ch <- RMSG{map_change}
	}


	if WM.aliens.Len() == 0 {
		Srv.sig <- true 
	} 

	
}  
